## 2024-05-23 - Stored XSS in Offline-First App
**Vulnerability:** Stored XSS via `localStorage` import features. The app trusted local storage data implicitly, assuming it was only generated by the app itself. However, the import feature allows external data to enter `localStorage` without content sanitization.
**Learning:** "Offline-first" or "Local-first" apps often neglect input validation because they treat the local database as a trusted zone. Data import features bridge the gap between untrusted external world and trusted local storage, bypassing standard API validation layers.
**Prevention:** Sanitize data at the *rendering* layer (Output Encoding) regardless of source. Also, validate/sanitize imported data at the *entry* point (Input Validation), ensuring it conforms to expected schemas (e.g. valid UUIDs).

## 2024-10-18 - Nested Validation Gap & Duplicated Logic
**Vulnerability:** XSS via `localStorage` import. The validation logic (`Validator`) checked the session structure but failed to validate nested objects (exercises) recursively. Additionally, `Storage.importData` implemented its own weak validation instead of using the central `Validator`.
**Learning:** Shallow validation is insufficient for complex data structures. Also, "Don't Repeat Yourself" (DRY) is a security principleâ€”duplicated validation logic often leads to one version being weaker than the other.
**Prevention:** Recursively validate all nested objects. Centralize validation logic in a single module and enforce its use across all data entry points (UI, API, Import).

## 2024-10-24 - Incomplete Nested Object Validation
**Vulnerability:** `Validator.validateSession` validated the main `exercises` array but ignored other nested structures (`warmup`, `cardio`, `decompress`). This allowed malformed data (e.g., strings instead of arrays) to be imported, potentially causing runtime crashes or future injection vulnerabilities.
**Learning:** Partial validation of complex schemas creates blind spots. Validation logic must explicitly cover ALL fields in the schema, including optional ones, to ensure complete data integrity.
**Prevention:** Implement comprehensive schema validation that recursively validates every nested object and array, ensuring strict type checking for all properties.

## 2026-01-23 - XSS via innerHTML in UI Event Handlers
**Vulnerability:** XSS in `swapAlt()` function (app.js:460) used `innerHTML` to update exercise names when users selected alternatives. While the dropdown values came from configuration, using `innerHTML` with any controllable data creates attack vectors through localStorage corruption or future code changes that allow user-defined alternatives.
**Learning:** Having a `Sanitizer` module doesn't prevent XSS if developers bypass it. Simple text updates should ALWAYS use `textContent` instead of `innerHTML`. The principle: "Never use innerHTML unless you're intentionally rendering HTML" - and even then, always sanitize.
**Prevention:** Use `textContent` for all text-only updates. Reserve `innerHTML` exclusively for cases where HTML rendering is required, and enforce sanitization at those points. Add linting rules to flag unsafe `innerHTML` usage.

## 2026-01-23 - Reverse Tabnabbing via External Links
**Vulnerability:** All video tutorial links (YouTube) used `target="_blank"` without `rel="noopener noreferrer"`. This allows opened pages to access `window.opener` and potentially navigate the PWA to a malicious phishing site (reverse tabnabbing). Found in 4 locations: warmup videos (app.js:213), lifting videos (245), cardio videos (273), and decompression videos (287).
**Learning:** External links with `target="_blank"` are a classic attack vector. Modern browsers partially mitigate this, but explicit protection is required for older browsers and defense-in-depth. The `noreferrer` attribute also prevents the Referer header from leaking the PWA's URL to external sites.
**Prevention:** ALWAYS use `rel="noopener noreferrer"` on external links with `target="_blank"`. For dynamic link updates via JavaScript (swapAlt, swapCardioLink functions), explicitly set the rel property to ensure protection persists across link changes.
